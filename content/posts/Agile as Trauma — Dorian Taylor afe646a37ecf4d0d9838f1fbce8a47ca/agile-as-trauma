<?xml version="1.0"?>
<?xml-stylesheet href="/transform" type="text/xsl"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:bibo="http://purl.org/ontology/bibo/" xmlns:bs="http://purl.org/ontology/bibo/status/" xmlns:ci="https://privatealpha.com/ontology/content-inventory/1#" xmlns:dct="http://purl.org/dc/terms/" xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:xhv="http://www.w3.org/1999/xhtml/vocab#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#" lang="en" prefix="bibo: http://purl.org/ontology/bibo/ bs: http://purl.org/ontology/bibo/status/ ci: https://privatealpha.com/ontology/content-inventory/1# dct: http://purl.org/dc/terms/ foaf: http://xmlns.com/foaf/0.1/ rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# xhv: http://www.w3.org/1999/xhtml/vocab# xsd: http://www.w3.org/2001/XMLSchema#" vocab="http://www.w3.org/1999/xhtml/vocab#" xml:lang="en">
  <head>
    <title property="dct:title">Agile as Trauma</title>
    <base href="https://doriantaylor.com/agile-as-trauma"/>
    <link href="document-stats#E0I7vjQp11eOs_IR1AcU8J" rev="ci:document"/>
    <link href="elsewhere" rel="alternate bookmark" title="Elsewhere"/>
    <link href="this-site" rel="alternate index" title="This Site"/>
    <link href="http://purl.org/ontology/bibo/status/published" rel="bibo:status"/>
    <link href="" rel="ci:canonical" title="Agile as Trauma"/>
    <link href="person/dorian-taylor#me" rel="dct:creator" title="Dorian Taylor"/>
    <link href="file/skateboard-scooter-bike-ah-fuckit;scale=955,500" rel="foaf:depiction"/>
    <link href="person/dorian-taylor" rel="meta" title="Who I Am"/>
    <link about="./" href="3f36c30c-6096-454a-8a22-c062100ae41f" rel="alternate dct:hasPart dct:references" type="application/atom+xml"/>
    <link about="./" href="f07f5044-01bc-472d-9079-9b07771b731c" rel="alternate dct:hasPart dct:references" type="application/atom+xml"/>
    <link about="./" href="this-site" rel="alternate index"/>
    <link about="./" href="elsewhere" rel="alternate bookmark"/>
    <link about="./" href="e341ca62-0387-4cea-b69a-cdabc7656871" rel="alternate dct:hasPart" type="application/atom+xml"/>
    <link about="verso/" href="3f36c30c-6096-454a-8a22-c062100ae41f" rel="alternate dct:hasPart dct:references" type="application/atom+xml"/>
    <link about="verso/" href="this-site" rel="alternate index"/>
    <link about="verso/" href="elsewhere" rel="alternate bookmark"/>
    <meta content="What if the Agile software movement was the manifestation of an entire industry that was, just, like, dealing with some stuff right now?" name="description" property="dct:abstract"/>
    <meta content="2020-02-08T20:37:50+00:00" datatype="xsd:dateTime" property="dct:created"/>
    <meta content="2020-03-01T20:18:49+00:00" datatype="xsd:dateTime" property="dct:modified"/>
    <meta content="2021-02-23T06:15:51+00:00" datatype="xsd:dateTime" property="dct:modified"/>
    <meta about="person/dorian-taylor#me" content="Dorian Taylor" name="author" property="foaf:name"/>
    <meta content="summary_large_image" name="twitter:card"/>
    <meta content="@doriantaylor" name="twitter:site"/>
    <meta content="Agile as Trauma" name="twitter:title"/>
    <meta content="What if the Agile software movement was the manifestation of an entire industry that was, just, like, dealing with some stuff right now?" name="twitter:description"/>
    <meta content="https://doriantaylor.com/file/skateboard-scooter-bike-ah-fuckit;scale=955,500" name="twitter:image"/>
    <object>
      <nav>
        <ul>
          <li>
            <a href="//dorian.substack.com/p/eye-of-newt-and-stack-of-sub" rev="dct:references" typeof="bibo:Article">
              <span property="dct:title">Eye of Newt and Stack of Sub</span>
            </a>
          </li>
        </ul>
      </nav>
    </object>
  </head>
  <body about="" typeof="bibo:Article">
    <section>
      <p>The <a href="//agilemanifesto.org/" rel="dct:references">Agile Manifesto</a> is an immune response on the part of programmers to bad management. The document is <a href="//agilemanifesto.org/history.html" rel="dct:references">an expression of trauma</a>, and its intellectual descendants continue to carry this baggage. While the Agile era has brought about remarkable advancements in project management techniques and development tools, it remains a tactical, technical, and ultimately reactionary movement. As long as Agile remains in this position it will be liable to backfire, vulnerable to the very depredations of bad management it had initially evolved to counter.</p>
      <p>In order to begin to heal, it is important to place Agile in a wider context. Many of the substantive ideas associated with Agile predate it by between about 20 and 30 years. This is not an accusation of plagiarism; rather it is an assertion that <span class="parenthesis" title="indeed I argue elsewhere that software is a special case of creative work in general">there are idiosyncrasies of software development</span> that are invariant even as technique and technology improves, and so you are bound to recapitulate these patterns eventually. The patterns include, but are not necessarily limited to:</p>
      <dl>
        <dt>Incremental development</dt>
        <dd>Software is created in modules: Just as books are composed of chapters, which are composed of <span class="parenthesis" title="implicit or explicit">sections</span>, paragraphs, and sentences, which themselves&#x2014;in code as in text&#x2014;are laid out word by word. Basic structures cannot be composed into larger structures unless they themselves are internally consistent, and so the creation of software, just like any artifact of language, is naturally incremental.</dd>
        <dt>Iterative development</dt>
        <dd>Not to be confused with <em>incremental</em> development. Software is a very verbose, very precise <em>incantation</em> of how an information system ought to <em>behave</em>. The entire process reduces to gaining information <em>about</em> the information <em>system</em> and gelling it into formal language&#x2014;a process that will never naturally terminate if you continue to provide it with resources: you can <em>always</em> go back and refine what you have written, and the need for <em>some</em> revisitation over time is the rule.</dd>
        <dt>Cross-functional teams</dt>
        <dd>Because software development reduces to gathering and concentrating information, it is obvious that that information will come from various sources, and the people responsible for said gathering and concentrating will have different expertise. Also, programming itself is a quasi-solipsistic activity. A programmer <em>requires</em>, <span class="parenthesis" title="there are arguments that pair programming reduces the initial injection of defects, but defects will not stop an individual person from producing code that &#x201C;functions&#x201D;  for some value of the term, and doesn't crash">strictly speaking</span>, no more collaboration than does a novelist or painter. Because software development is naturally incremental, people can work on different parts of a system in parallel. This naturally lends itself to variegated expertise among programmers themselves.</dd>
        <dt>Fixed time, variable scope</dt>
        <dd>Just like content development in any other medium, software development reduces to the elimination of entropy. <em>Unlike</em> other media, however, there is very little else to <em>count</em>. The problem is that you and/or your team can <span class="parenthesis" title="which is concave to the number of people on the team">only eliminate a fixed-ish number of bits of entropy per unit time</span>, and at the outset you don't know how many bits there are in the problem to eliminate. So you say <q>we're gonna work <em>this</em> much, and whatever comes out the other end of that process is whatever you get.</q> In the current theory, and sometimes in practice, this is how <dfn>sprints</dfn> are supposed to work, and the material that doesn't fit is accumulated into some <dfn>backlog</dfn> or other.</dd>
        <dt>User involvement</dt>
        <dd>Since the purpose of software is putatively to serve users, it should not be surprising that users constitute an essential source of information, up to and including their interactions with prototypes and as paying customers of what has come to be called a <dfn>minimum viable product</dfn>.</dd>
      </dl>
      <p>To the extent that trauma is by definition something you don't <q>get over</q>, and only eventually come to <q>understand</q>, I submit that the Agile-o-sphere continually relitigates <span class="parenthesis" title="and others not mentioned">these issues</span> at the expense of solving other, potentially more fruitful problems.</p>
    </section>
    <section>
      <h2>What We Hear Suspiciously Much About</h2>
      <p><strong>Collaboration!</strong> <em>So</em> much effort goes into writing and talking about collaboration, and creating tools to facilitate collaboration and telecollaboration, with the tacit assumption that more collaboration is always better. <a type="audio/mpeg" href="http://www.oopsla.org/podcasts/Keynote_FrederickBrooks.mp3#t=535" rel="dct:references">To quote Frederick Brooks</a>, the more collaboration the better <q>is far from a self-evident proposition and certainly not universally true.</q> <em>True indeed</em>, to the extent that collaboration divides labour, but questionable as a fraction of one's <em>activity</em>. Since communication overhead <a href="//en.wikipedia.org/wiki/Brooks%27s_law" rel="dct:references">increases proportionally the <em>square</em> of the number of people</a> on the team&#x2014;a fact illuminated by Brooks in the 1970s&#x2014;what you actually want is <span class="parenthesis" title="as a fraction of activity">as <em>little</em> collaboration</span> as you can get away with.</p>
      <p>One way all this lavish attention to collaboration makes sense, is that your team dynamic is something you can always affect, even if you have no meaningful influence over the major strategic decisions of an organization.</p>
    </section>
    <section>
      <h2>What We Don't Hear A Lot About</h2>
      <p>I'm sure these things <em>exist</em> in some form or other; the point is they don't get nearly as much attention.</p>
      <dl>
        <dt>Anything higher up the chain than project management</dt>
        <dd>In 20 years, Agile has given us standup meetings, sprints, pair programming, user stories, DevOps, and continuous integration. This is all tactical stuff. <a href="//www.youtube.com/watch?v=zTGX98HmXtg" rel="dct:references">Contracting gets a little attention</a>, but <em>nothing</em> like the attention heaped onto project management on down. Where are the people thinking and talking about Agile <em>procurement</em>, for example? Or Agile enterprise resource planning? This is important, because failures to implement Agile principles are often easily diagnosed as side effects of the constraints of antiquated procurement and contracting practices.</dd>
        <dt><a href="//www.youtube.com/watch?v=dDE_y7Qri9w" rel="dct:references">A specificity gradient</a></dt>
        <dd>
          <p>Software is unprecedented in its low cost of development&#x2014;when compared to hardware. Code, however, is arguably <span class="parenthesis" title="unless you're writing on marble or something">the most <em>expensive</em> medium for expressing ideas</span>. <a href="//blog.crisp.se/2016/01/25/henrikkniberg/making-sense-of-mvp" rel="dct:references">The popular meme</a> of maturing a product from skateboard, to bike, to motorcycle, to car is a cute story, but the way software tends to <em>actually</em> be made is more like going from engine, to drivetrain, to monocoque, to interior.</p>
          <p>Except software isn't like a car at all: if anything it's more like <a href="//www.amazon.com/dp/0195018249?tag=doriantaylor-20" rel="dct:references">a university campus</a>, where different buildings are complete artifacts in their own right but loosely couple together <span class="parenthesis" title="or indeed, numerous services, each unified, operating in parallel">to form a unified service</span>. It is perfectly reasonable for some parts to be undergoing construction while others are being planned. Taken as a whole at any given moment, some parts of the system <span class="parenthesis" title="that is, they will have been implemented">will have more detail</span> and others will have less. Our notions of iteration and incrementality therefore have to also make room for media other than code.</p>
        </dd>
        <dt>Conceptual friggin' integrity</dt>
        <dd>
          <p>The one idea from the 1970s most conspicuously absent from Agile discourse is <dfn>conceptual integrity</dfn>. This&#x2014;another contribution from Brooks&#x2014;is roughly the state of having a unified mental model of both the project <em>and</em> the user, shared among all members of the team. Conceptual integrity makes the product both easier to develop and easier to use, because this integrity is communicated to <span class="parenthesis" title="and with luck, upper management as well">both the development team <em>and</em> the user</span>, <em>through</em> the product.</p>
          <p>Without conceptual integrity, Brooks said, <q>there will be as many mental models as there are people on the team.</q> This state of affairs <strong>requires <em>somebody</em> to have the final say</strong> on strategic decisions. It furthermore requires this <span class="parenthesis before" title="singular">person</span> to have diverse enough expertise to mentally circumscribe&#x2014;and thus have a <em>vision</em> for&#x2014;the <em>entire</em> project in every way that was important, even if not precisely down to the last line of code.</p>
        </dd>
      </dl>
    </section>
    <section>
      <h2><q>Agile vs. Waterfall</q> is <a href="//en.wikipedia.org/wiki/Kayfabe" rel="dct:references">Kayfabe</a></h2>
      <p>Any Agile adherent can tell you that Waterfall is <em>bad</em>, and that if you aren't doing Agile, you must necessarily be doing Waterfall. It is clear, however, that comparatively few have actually <em>read</em> <span class="parenthesis" title="which doesn&#x2019;t actually use the term &#x201C;waterfall&#x201D;">the 1970 Waterfall <em>paper</em></span>. If they <em>had</em>, they would learn that what they had experienced&#x2014;or more likely, heard about&#x2014;was what the paper's author asserted was the <em>wrong</em> way to manage a software project. One may even be led to interrogate just <em>why</em> it is that such a known-bad practice is what developers ended up using for so many years.</p>
      <p>There is the story that so-called <q>big design up front</q>&#x2014;another Agile shibboleth&#x2014;was more of a necessity in the past because:</p>
      <ul>
        <li>available computing resources were a minuscule fraction of what they are today, and thus required more planning,</li>
        <li>programming was just plain slower, and</li>
        <li>distribution logistics&#x2014;shipping on physical tapes, floppy disks, ROM cartridges, CDs&#x2014;put a cap on the release cycle.</li>
      </ul>
      <p>There is furthermore the argument that the product in question must get to market as quickly as possible to secure the first-mover advantage, or perhaps in its gentler form, the idea has to be tested in the market right away to make sure it's something people want. <span class="parenthesis" title="except maybe the last one">None of these statements are false</span>, but they aren't the whole truth either.</p>
      <p>In particular, not all software is a Web app. Indeed, a sizable fraction of software is not a consumer product, or not even a <q>product</q> at all. We discount the volume of, for instance, embedded systems and one-off infrastructure. The former have a release cycle pinned to their host hardware; the latter you can update whenever it's sufficiently convenient. Both categories of software existed 50 years ago as they do today, and will continue to exist into the foreseeable future: In 2020 there are plenty of systems that are <span class="parenthesis" title="launched into space, for example">effectively un-updateable</span>; in 1970 there were plenty of systems where you could <span class="parenthesis" title="Lisp and Smalltalk, for example&#x2014;and not counting all the ones you weren't technically supposed to">inject new code straight into a running program</span>.</p>
      <p>The story that things were slow and now they're fast&#x2014;technology and market forces alike&#x2014;is not sufficient to explain the pervasive adoption of what has come to be called <em>Waterfall</em>. The story is especially ill-fitting considering preeminent figures in software development had been advocating incremental and iterative development with feedback from users, up to and including the original 1970 Waterfall paper itself.</p>
      <p>I want you to consider instead the possibility that Waterfall came to exist, and continues to exist, for the convenience of <em>managers</em>: people whose <a href="//www.amazon.com/dp/0674940520?tag=doriantaylor-20" rel="dct:references">methods are inherited</a> from <a href="//www.amazon.com/dp/0674057597?tag=doriantaylor-20" rel="dct:references">military and civil engineering</a>, and who, more than anything else, need you to promise them something <em>specific</em>, and then <span class="parenthesis" title="no more, no less">deliver <em>exactly</em> what you promised them</span>, <span class="parenthesis" title="and in the precise order"><em>when</em></span> you promised you'd deliver it. There exists many a corner office whose occupant, if forced to choose, will take an absence of surprises over a substantive outcome.</p>
      <p>This alternative theory would further explain the <abbr title="Request for Proposals">RFPs</abbr> that go out that insist on Agile processes while also demanding a formal specification up front with a detailed prescription of feature milestones&#x2014;or as they like to call them, <q><em>phases</em></q>&#x2014;and their concomitant deadlines.</p>
      <p>My final remark on this subject is that the rhetorical framing around <em>design</em> as something inherently belonging to Waterfall, and thus <em>bad</em> and an impediment to shipping product. This is little more than a goad, perpetrated <span class="parenthesis" title="though they may subscribe to that position if they knew it was available">not so much by professional managers</span>, but anxious startup founders worried about their money running out before they start earning any. Software development, again, is about answering thousands of questions. Some of those questions can only be answered with code; others can never be. There is nothing preventing these operations from being carried out in parallel, except when one genuinely depends on the completion of the other.</p>
    </section>
    <section>
      <h2><a href="//en.wikipedia.org/wiki/Goodhart%27s_law" rel="dct:references">Goodhart's Curse</a></h2>
      <p>A <dfn>feature</dfn> is a unit of programmer output that corresponds roughly to <span class="parenthesis" title="one or more; functions, methods, whatever you want to call them">a <dfn>subroutine</dfn></span>. Features work as a management control because they manifest in the final product, and their relationship to programmer-hours is about as close to linear as you're going to get.</p>
      <p>Features also work for marketing. Since nobody can deny a feature exists, a convenient tactic is just to count them: <q>Over 100 new features in our latest release!</q> Any time, likewise, the messaging reads something like <q>our product lets you&#x2026;</q>, they're talking about features. Indeed, marketing departments everywhere would be adrift without the venerable feature to fall back on.</p>
      <p>Features <em>don't</em> work, in the sense that they can be easily <em>gamed</em>. A brittle and perfunctory implementation, done quickly, is going to score more intramural brownie points over a robust and complete one. If the question is <q>does product <var>A</var> have feature <var>X</var>?</q> then the answer is <em>yes</em> either way. This also makes features a spurious basis for comparison in competing products because you need to seriously examine them to determine the extent to which they are any good.</p>
      <p>We use the term <dfn>feature factory</dfn> as a pejorative to designate companies addicted to adding features, while accumulating incalculable <span class="parenthesis" title="I have Feelings&#x2122; about this term but I will deal with those elsewhere.">so-called <dfn>technical debt</dfn>.</span> This situation is driven by management for the convenience of marketing, and I am skeptical that a more faithful application of Agile principles will correct it. Indeed, I suspect Agile processes are constitutionally vulnerable to this kind of compromise.</p>
      <p>There is, however, another objectively countable phenomenon associated with software development, and that is <em>behaviour</em>. The question <q>does the product do <var>X</var>, optionally under condition <var>Y</var>?</q> is <em>also</em> an empirical question with a yes-or-no answer. Programmers should be familiar with this pattern; it is exactly how test suites are written.</p>
      <p>Behaviour has an advantage over features in that you can describe any feature in terms of behaviour, but you can't describe behaviour in terms of features. This is because features are visible <span class="parenthesis" title="such that Marketing can take screenshots and print them in magazines">while the software is sitting still</span>, whereas behaviour is only visible while the software is running. Moreover, the presence of a feature can only indicate to a user if a goal is <em>possible</em>, behaviour will determine <span class="parenthesis" title="or not">how painful</span> it will be to achieve it.</p>
      <p>The final advantage of behaviour that I will discuss here is the fact that it blurs the line between <q>fixing bugs</q> and <q>building features</q>, and coalesces the two into a unitary process of <q>sculpting behaviour</q>. <span class="parenthesis" title="far from a bad thing">The feature count may not go up as quickly</span>, but the product's behaviour will increase steadily in subtlety and fit. My bet is also that behaviour is less amenable to be gamed because <span class="parenthesis" title="But then, of course, invent a foolproof system and the universe will respond with a superior fool.">any attempt is going to look really obvious and silly.</span> The marketing department can fend for themselves mining the corpus for identifiable features; they pretty much do that already anyway.</p>
      
    </section>
    <section>
      <h2>When is a Sprint Really a Marathon?</h2>
      <p>Like any other creative endeavour, software development can't be <em>sped up</em> as much as we can eliminate the phenomena that <em>slow it down</em>. Advancements in process and tooling, and the computing resources to run them, can be interpreted as doing exactly this. The result is that developers can spend <span class="parenthesis" title="I am really just pulling this statement out of my ass and actually have reason to doubt it">a larger fraction of their time on application logic</span>. The application logic itself gets coarser and coarser-grained with each passing year. Ideally, you could just tell the computer what you want and it would fabricate it, but if you could do this, then there would be no need for programmers.</p>
      <p>Even in a world after programmers, there will still be the work of figuring out&#x2014;albeit no longer in <em>code</em>&#x2014;just <em>what</em> you want to tell the computer to do for you&#x2014;<em>how</em> you want it to behave. There are still a <em>lot</em> of decisions to make aside from what framework you write it in, or whether you use <abbr>NoSQL</abbr>, or how you lay out the source tree. If you eliminate the decisions that involve getting the artifact to work <span class="parenthesis before" title="from a technical standpoint">at <em>all</em></span>, the remaining decisions are going to involve whether it works better one way than another. Most of these decisions are going to be the result of trial and error, and a sizable chunk of <em>those</em> are going to involve feedback from users.</p>
      <p>It helps to know that people were <q>uncovering better ways of developing software</q> long before the Agile Manifesto was written, because it puts it into context. It enables us to understand the constitutional limitations and consider how to grow beyond them.</p>
      <p>A development paradigm that can be construed from the outside as setting great store by speed&#x2014;<span class="parenthesis" title="it is a vector quantity after all">or, I suppose, <em>velocity</em></span>&#x2014;is invariably going to be under continuous political and economic pressure to accelerate. It isn't clear from the literature that this was <span class="parenthesis" title="in fact they explicitly mention a constant frequency of delivery">anticipated by the Manifesto's signatories</span>. If instead you asserted that the work amounts to continual discovery, it happens at <em>one</em> speed, and could potentially continue indefinitely, you might be able to pace yourself.</p>
    </section>
    <section>
      <h2>Further Reading</h2>
      <p>These papers and books advocating principles recognizable in Agile literature are ones I have personally encountered. I am sure there are more.</p>
      <dl>
        <dt>1970: <a type="application/pdf" href="http://www-scf.usc.edu/~csci201/lectures/Lecture11/royce1970.pdf" rel="dct:references">Managing the Development of Large Software Systems</a></dt>
        <dd>The original Waterfall paper by <a href="//en.wikipedia.org/wiki/Winston_W._Royce" rel="dct:references">Winston Royce</a>, in which he introduces the Waterfall model as an obvious and deliberate straw man, and makes a pretty clear case for a feedback loop.</dd>
        <dt>1971: <a href="http://sunnyday.mit.edu/16.355/wirth-refinement.html" rel="dct:references">Program Development by Stepwise Refinement</a></dt>
        <dd>An important paper on iteration by <a href="//en.wikipedia.org/wiki/Niklaus_Wirth" rel="dct:references">Niklaus Wirth</a>.</dd>
        <dt>1975: <a href="//www.amazon.com/dp/0201835959?tag=doriantaylor-20" rel="dct:references">The Mythical Man-Month</a></dt>
        <dd>The quintessential volume on software design and project management, by <a href="//en.wikipedia.org/wiki/Fred_Brooks" rel="dct:references">Frederick Brooks</a>.</dd>
        <dt>1980: <a href="//ieeexplore.ieee.org/document/1456074" rel="dct:references">Programs, Life Cycles, and Laws of Software Evolution</a></dt>
        <dd>One of the agglomerating papers on Meir <a href="//en.wikipedia.org/wiki/Lehman%27s_laws_of_software_evolution" rel="dct:references">Lehman's Laws of Software Evolution</a>, which date back to 1974.</dd>
        <dt>1981: <a href="//www.amazon.com/dp/0138221227?tag=doriantaylor-20" rel="dct:references">Software Engineering Economics</a></dt>
        <dd>Most of this 800-page tome by <a href="//en.wikipedia.org/wiki/Barry_Boehm" rel="dct:references">Barry Boehm</a> is about estimating Waterfall-esque projects, but the introductory chapters deal with, among other things, uncertainty and feedback from users.</dd>
        <dt>1988: <a href="//ieeexplore.ieee.org/document/59" rel="dct:references">A Spiral Model of Software Development and Enhancement</a></dt>
        <dd>A subsequent meditation by Boehm on incrementalism, iteration and risk.</dd>
      </dl>
      <p>I should also note that while it is somewhat obliquely related to the content of this particular document, the thing that got me exercised enough to write it is a podcast episode by <a href="//twitter.com/lauraklein" rel="dct:references">Laura Klein</a> and <a href="//twitter.com/katerutter" rel="dct:references">Kate Rutter</a>, <q><a href="//www.usersknow.com/podcast/2020/1/14/problems-with-agile-ux" rel="dct:references">Problems with Agile <abbr title="user experience design">UX</abbr></a></q>.</p>
    </section>
  </body>
</html>
